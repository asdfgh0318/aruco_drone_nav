<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ArUco DroneNav GLB Viewer</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #1a1a2e; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #e0e0e0; }

#navbar {
  display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
  background: #16213e; padding: 6px 16px; min-height: 48px;
  border-bottom: 1px solid #0f3460; z-index: 100; position: relative;
}
#navbar h1 { font-size: 15px; font-weight: 600; color: #e94560; white-space: nowrap; }
#navbar .sep { width: 1px; height: 24px; background: #0f3460; }
.file-btn {
  position: relative; cursor: pointer;
  padding: 4px 10px; border-radius: 4px; font-size: 12px;
  background: #0f3460; color: #e0e0e0; border: 1px solid #1a4080;
  transition: background 0.15s;
}
.file-btn:hover { background: #1a4080; }
.file-btn input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }

.origin-group { display: flex; align-items: center; gap: 4px; font-size: 11px; color: #888; }
.origin-group label { white-space: nowrap; }
.origin-group input {
  width: 90px; padding: 2px 4px; font-size: 11px; font-family: monospace;
  background: #0a1830; color: #e0e0e0; border: 1px solid #0f3460; border-radius: 3px;
}
#navbar .hint { font-size: 11px; color: #555; white-space: nowrap; }

#viewport { position: absolute; top: 48px; left: 0; right: 0; bottom: 0; }

.panel {
  position: absolute; background: rgba(22,33,62,0.88); border: 1px solid #0f3460;
  border-radius: 6px; padding: 10px 14px; font-size: 12px; line-height: 1.6;
  pointer-events: none; backdrop-filter: blur(4px);
}
.panel b { color: #e94560; }
.panel .label { color: #888; }

#info-panel { top: 12px; right: 12px; min-width: 220px; display: none; }
#legend-panel { top: 12px; right: 12px; display: none; }
#stats-panel { bottom: 12px; left: 12px; display: none; }

/* Toggle panel - interactive */
#toggle-panel {
  position: absolute; top: 12px; left: 12px;
  background: rgba(22,33,62,0.92); border: 1px solid #0f3460;
  border-radius: 6px; padding: 10px 14px; font-size: 12px; line-height: 1.8;
  pointer-events: auto; backdrop-filter: blur(4px); display: none; z-index: 20;
}
#toggle-panel b { color: #e94560; }
#toggle-panel label { display: flex; align-items: center; gap: 6px; cursor: pointer; white-space: nowrap; }
#toggle-panel input[type=checkbox] { accent-color: #e94560; cursor: pointer; }
.toggle-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
.toggle-line { display: inline-block; width: 14px; height: 3px; border-radius: 1px; }

/* Convert panel - interactive */
#convert-panel {
  position: absolute; bottom: 12px; right: 12px;
  background: rgba(22,33,62,0.92); border: 1px solid #0f3460;
  border-radius: 6px; padding: 10px 14px; font-size: 12px; line-height: 1.8;
  pointer-events: auto; backdrop-filter: blur(4px); display: none; z-index: 20;
  min-width: 220px;
}
#convert-panel b { color: #e94560; }
#convert-panel .conv-row { display: flex; align-items: center; gap: 6px; white-space: nowrap; }
#convert-panel input[type=number] {
  width: 60px; padding: 2px 4px; font-size: 11px; font-family: monospace;
  background: #0a1830; color: #e0e0e0; border: 1px solid #0f3460; border-radius: 3px;
}
#convert-panel label.conv-check { display: flex; align-items: center; gap: 6px; cursor: pointer; white-space: nowrap; }
#convert-panel input[type=checkbox] { accent-color: #e94560; cursor: pointer; }
#convert-panel button {
  margin-top: 4px; padding: 5px 12px; border-radius: 4px; font-size: 12px; width: 100%;
  background: #0f3460; color: #e0e0e0; border: 1px solid #1a4080;
  cursor: pointer; transition: background 0.15s;
}
#convert-panel button:hover:not(:disabled) { background: #1a4080; }
#convert-panel button:disabled { opacity: 0.4; cursor: default; }
#convert-panel .conv-status { font-size: 11px; color: #888; margin-top: 2px; }

.legend-row { display: flex; align-items: center; gap: 6px; }
.legend-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }

#tooltip {
  position: absolute; background: rgba(22,33,62,0.94); border: 1px solid #e94560;
  border-radius: 4px; padding: 6px 10px; font-size: 11px; line-height: 1.5;
  pointer-events: none; display: none; z-index: 50; white-space: nowrap;
}

#loading {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
  font-size: 16px; color: #e94560; display: none;
}

#drop-overlay {
  position: absolute; inset: 0; background: rgba(233,69,96,0.12);
  border: 3px dashed #e94560; display: none; z-index: 40;
  justify-content: center; align-items: center; font-size: 20px; color: #e94560;
}
/* Help button */
#help-btn {
  width: 28px; height: 28px; border-radius: 50%; margin-left: auto;
  border: 1px solid #0f3460; background: #0f3460; color: #e94560;
  font-size: 14px; font-weight: bold; cursor: pointer; transition: background 0.15s;
}
#help-btn:hover { background: #1a4080; }

/* Tutorial overlay */
#tutorial-backdrop {
  position: fixed; inset: 0; background: rgba(0,0,0,0.6);
  z-index: 1000; display: none;
}
#tutorial-card {
  position: fixed; z-index: 1002; background: #16213e;
  border: 1px solid #e94560; border-radius: 8px; padding: 20px 24px;
  max-width: 380px; min-width: 280px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  transition: top 0.3s ease, left 0.3s ease; display: none;
}
#tutorial-card .tut-title { color: #e94560; font-size: 15px; font-weight: 600; margin: 0 0 8px; }
#tutorial-card .tut-body { font-size: 13px; line-height: 1.6; color: #ccc; margin-bottom: 16px; }
#tutorial-card .tut-body b { color: #e0e0e0; }
#tutorial-card .tut-footer { display: flex; align-items: center; justify-content: space-between; }
#tutorial-card .tut-step { font-size: 11px; color: #666; }
#tutorial-card .tut-btns { display: flex; gap: 8px; }
#tutorial-card .tut-btns button {
  padding: 5px 14px; border-radius: 4px; font-size: 12px; cursor: pointer;
  border: 1px solid #0f3460; background: #0f3460; color: #e0e0e0; transition: background 0.15s;
}
#tutorial-card .tut-btns button:hover { background: #1a4080; }
#tutorial-card .tut-btns .tut-primary { background: #e94560; border-color: #e94560; color: #fff; }
#tutorial-card .tut-btns .tut-primary:hover { background: #c73a52; }
#tutorial-card .tut-btns .tut-skip { background: transparent; border-color: transparent; color: #666; }
#tutorial-card .tut-btns .tut-skip:hover { color: #999; }
.tutorial-highlight {
  position: relative !important; z-index: 1001 !important;
  box-shadow: 0 0 0 4px #e94560, 0 0 16px rgba(233,69,96,0.4) !important;
  border-radius: 4px;
}
</style>
</head>
<body>

<div id="navbar">
  <h1>ArUco DroneNav GLB Viewer</h1>
  <div class="sep"></div>
  <div id="file-btns-group" style="display:flex;align-items:center;gap:10px">
    <label class="file-btn">GLB<input type="file" id="glb-input" accept=".glb,.gltf"></label>
    <label class="file-btn">JSON<input type="file" id="json-input" accept=".json"></label>
    <label class="file-btn" style="background:#2a1a40;border-color:#4a2a70">WPL<input type="file" id="wpl-input" accept=".waypoints,.txt"></label>
  </div>
  <div class="sep"></div>
  <div id="coords-group" style="display:flex;align-items:center;gap:10px">
    <div class="origin-group">
      <label>Origin:</label>
      <input id="origin-lat" type="text" value="52.2297" title="Origin latitude">
      <input id="origin-lon" type="text" value="21.0122" title="Origin longitude">
    </div>
    <div class="origin-group">
      <label>StartAlt:</label>
      <input id="start-alt" type="text" value="0" title="Unity Y of arming point (auto-set from JSON)" style="width:60px">
    </div>
  </div>
  <button id="help-btn" title="Tutorial">?</button>
  <span class="hint">R=reset &nbsp;G=grid &nbsp;T=traj &nbsp;W=wp &nbsp;A=ardupilot &nbsp;C=convert &nbsp;?=help</span>
</div>

<div id="viewport">
  <div id="drop-overlay">Drop GLB / JSON / .waypoints file here</div>
  <div id="loading">Loading...</div>

  <!-- Toggle checkboxes panel -->
  <div id="toggle-panel">
    <div><b>Layers</b></div>
    <label><input type="checkbox" id="chk-trajectory" checked>
      <span class="toggle-line" style="background:#00aaff"></span> Flight path (JSON)</label>
    <label><input type="checkbox" id="chk-waypoints" checked>
      <span class="toggle-dot" style="background:#ffdd00"></span> Waypoints (JSON)</label>
    <label><input type="checkbox" id="chk-ardupilot" checked>
      <span class="toggle-dot" style="background:#cc44ff"></span> ArduPilot WPs</label>
    <label><input type="checkbox" id="chk-ardu-line" checked>
      <span class="toggle-line" style="background:#cc44ff"></span> ArduPilot path</label>
    <label><input type="checkbox" id="chk-grid" checked>
      <span class="toggle-line" style="background:#0f3460"></span> Grid / Axes</label>
  </div>

  <div class="panel" id="info-panel">
    <div><b>Clicked Point</b></div>
    <div>Unity: <span id="info-unity">—</span></div>
    <div>NED: <span id="info-ned">—</span></div>
    <div>Alt: <span id="info-alt">—</span></div>
  </div>

  <div class="panel" id="legend-panel">
    <div><b>Waypoint Types</b></div>
    <div class="legend-row"><span class="legend-dot" style="background:#00ff88"></span> FlyThrough</div>
    <div class="legend-row"><span class="legend-dot" style="background:#ffdd00"></span> StopRotate</div>
    <div class="legend-row"><span class="legend-dot" style="background:#ff4444"></span> Record360</div>
    <div class="legend-row" style="margin-top:4px"><span class="legend-dot" style="background:#cc44ff"></span> ArduPilot WP</div>
    <div class="legend-row"><span style="color:#ff8800">▲</span> Takeoff &nbsp; <span style="color:#ff0000">▼</span> Land</div>
  </div>

  <!-- Convert panel -->
  <div id="convert-panel">
    <div><b>Convert</b> <span style="float:right;cursor:pointer;color:#666" id="conv-close">&#x2715;</span></div>
    <div class="conv-row"><span style="color:#888">Alt offset:</span><input type="number" id="conv-alt-offset" value="0" step="0.1"></div>
    <div class="conv-row"><span style="color:#888">360° time:</span><input type="number" id="conv-360-time" value="30" step="1">s</div>
    <label class="conv-check"><input type="checkbox" id="conv-no-takeoff"> No takeoff</label>
    <label class="conv-check"><input type="checkbox" id="conv-no-land"> No land</label>
    <button id="conv-btn" disabled>JSON &#x2192; .waypoints</button>
    <div class="conv-status" id="conv-status"></div>
  </div>

  <div class="panel" id="stats-panel"></div>
  <div id="tooltip"></div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { Line2 } from 'three/addons/lines/Line2.js';
import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

// ── State ──
let modelGroup = null;
let waypointGroup = null;
let trajectoryGroup = null;
let ardupilotGroup = null;
let ardupilotLineGroup = null;
let clickMarker = null;
let gridHelper = null;
let axesHelper = null;

// Store JSON data for conversion
let jsonStartAlt = 0;
let jsonLoaded = false;
let jsonData = null;
let jsonFileName = '';

const WP_COLORS = { 0: 0x00ff88, 1: 0xffdd00, 2: 0xff4444 };
const WP_NAMES = { 0: 'FlyThrough', 1: 'StopRotate', 2: 'Record360' };
// MAV_CMD
const CMD_WAYPOINT = 16, CMD_TAKEOFF = 22, CMD_LAND = 21, CMD_LOITER_TIME = 19;

// Unity→scene: GLB exporter negates X
const toScene = (p) => ({ x: -p.x, y: p.y, z: p.z });

// ── Scene setup ──
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a2e);

const camera = new THREE.PerspectiveCamera(60, 1, 0.05, 500);
camera.position.set(10, 10, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
const viewport = document.getElementById('viewport');
viewport.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(10, 20, 10);
scene.add(dirLight);

// Grid + Axes
gridHelper = new THREE.GridHelper(50, 50, 0x0f3460, 0x0a1830);
scene.add(gridHelper);
axesHelper = new THREE.AxesHelper(5);
scene.add(axesHelper);

// Click marker
clickMarker = new THREE.Mesh(
  new THREE.SphereGeometry(0.06, 16, 16),
  new THREE.MeshBasicMaterial({ color: 0xff0000 })
);
clickMarker.visible = false;
scene.add(clickMarker);

// Raycasters
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// ── Resize ──
function onResize() {
  const w = viewport.clientWidth, h = viewport.clientHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
}
window.addEventListener('resize', onResize);
onResize();

// ── Animation loop ──
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

// ── Helpers ──
function fmtN(v, d = 3) { return v.toFixed(d); }

function unityToNED(p) {
  return { n: p.z, e: p.x, d: -p.y, alt: p.y };
}

function getOrigin() {
  return {
    lat: parseFloat(document.getElementById('origin-lat').value) || 52.2297,
    lon: parseFloat(document.getElementById('origin-lon').value) || 21.0122,
  };
}

function fitCameraToBox(box) {
  const center = new THREE.Vector3();
  const size = new THREE.Vector3();
  box.getCenter(center);
  box.getSize(size);
  const radius = size.length() / 2;
  const dist = radius / Math.tan(THREE.MathUtils.degToRad(camera.fov / 2)) * 1.3;
  camera.position.set(center.x + dist * 0.5, center.y + dist * 0.6, center.z + dist * 0.5);
  controls.target.copy(center);
  controls.update();
}

// ── GLB Loading ──
const gltfLoader = new GLTFLoader();

function loadGLB(arrayBuffer, fileName) {
  document.getElementById('loading').style.display = 'block';
  if (modelGroup) { scene.remove(modelGroup); }

  gltfLoader.parse(arrayBuffer, '', (gltf) => {
    modelGroup = gltf.scene;
    scene.add(modelGroup);
    const box = new THREE.Box3().setFromObject(modelGroup);
    fitCameraToBox(box);
    document.getElementById('loading').style.display = 'none';
    updateStats({ model: fileName, box });
  }, (err) => {
    document.getElementById('loading').style.display = 'none';
    alert('Failed to load GLB: ' + err.message);
  });
}

// ── JSON Trajectory Loading ──
function loadTrajectory(data, fileName) {
  if (waypointGroup) { scene.remove(waypointGroup); }
  if (trajectoryGroup) { scene.remove(trajectoryGroup); }

  waypointGroup = new THREE.Group();
  waypointGroup.name = 'waypoints';
  trajectoryGroup = new THREE.Group();
  trajectoryGroup.name = 'trajectory';

  const waypoints = data.detailedWaypoints || [];
  const segments = data.detailedSegments || [];
  const samples = (data.dronePlannedMovement && data.dronePlannedMovement.samples) || [];

  // Store start altitude for WPL reverse conversion
  if (segments.length > 0) {
    jsonStartAlt = segments[0].fromPos.y;
  } else if (waypoints.length > 0) {
    jsonStartAlt = waypoints[0].position.y;
  }
  jsonLoaded = true;
  jsonData = data;
  document.getElementById('start-alt').value = jsonStartAlt.toFixed(4);
  document.getElementById('conv-btn').disabled = false;
  document.getElementById('conv-status').textContent = '';

  // ── Flight path from samples ──
  if (samples.length > 1) {
    const positions = [];
    for (const s of samples) {
      const p = toScene(s.position);
      positions.push(p.x, p.y, p.z);
    }
    const lineGeo = new LineGeometry();
    lineGeo.setPositions(positions);
    const lineMat = new LineMaterial({
      color: 0x00aaff, linewidth: 3, worldUnits: false,
      transparent: true, opacity: 0.85,
    });
    lineMat.resolution.set(viewport.clientWidth, viewport.clientHeight);
    const line = new Line2(lineGeo, lineMat);
    line.computeLineDistances();
    trajectoryGroup.add(line);
  }

  // ── Waypoints ──
  const wpById = {};
  for (const wp of waypoints) {
    if (wp.wasDeleted) continue;
    wpById[wp.id] = wp;
  }

  // Traversal order from segments
  let orderedIds = null;
  if (segments.length > 0) {
    const nextWp = {};
    for (const seg of segments) { nextWp[seg.fromId] = seg.toId; }
    orderedIds = [];
    let current = nextWp[-1];
    const visited = new Set();
    while (current !== undefined && current !== -2 && !visited.has(current)) {
      if (wpById[current]) orderedIds.push(current);
      visited.add(current);
      current = nextWp[current];
    }
  }
  if (!orderedIds || orderedIds.length === 0) {
    orderedIds = Object.keys(wpById).map(Number);
  }

  const wpPositions = [];
  for (let i = 0; i < orderedIds.length; i++) {
    const wp = wpById[orderedIds[i]];
    const pos = wp.position;
    const sp = toScene(pos);
    const color = WP_COLORS[wp.type] || 0xffffff;

    // Sphere
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(0.15, 16, 16),
      new THREE.MeshBasicMaterial({ color })
    );
    sphere.position.set(sp.x, sp.y, sp.z);
    sphere.userData = {
      wpId: wp.id, type: wp.type, typeName: WP_NAMES[wp.type] || 'Unknown',
      yaw: wp.yaw || 0, position: pos, order: i + 1, source: 'json',
    };
    waypointGroup.add(sphere);
    wpPositions.push(new THREE.Vector3(sp.x, sp.y, sp.z));

    // Yaw cone
    const cone = new THREE.Mesh(
      new THREE.ConeGeometry(0.06, 0.3, 8),
      new THREE.MeshBasicMaterial({ color })
    );
    cone.rotation.x = Math.PI / 2;
    const pivot = new THREE.Group();
    pivot.position.set(sp.x, sp.y, sp.z);
    pivot.rotation.y = -THREE.MathUtils.degToRad(wp.yaw || 0);
    cone.position.z = 0.3;
    pivot.add(cone);
    waypointGroup.add(pivot);

    // Order label
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#000000';
    ctx.globalAlpha = 0.6;
    ctx.fillRect(0, 0, 64, 32);
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${i + 1}`, 32, 16);
    const tex = new THREE.CanvasTexture(canvas);
    const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
    const sprite = new THREE.Sprite(spriteMat);
    sprite.position.set(sp.x, sp.y + 0.35, sp.z);
    sprite.scale.set(0.5, 0.25, 1);
    waypointGroup.add(sprite);
  }

  // Dashed connector line
  if (wpPositions.length > 1) {
    const geo = new THREE.BufferGeometry().setFromPoints(wpPositions);
    const mat = new THREE.LineDashedMaterial({
      color: 0xffffff, dashSize: 0.3, gapSize: 0.15,
      transparent: true, opacity: 0.6,
    });
    const dashLine = new THREE.Line(geo, mat);
    dashLine.computeLineDistances();
    waypointGroup.add(dashLine);
  }

  scene.add(trajectoryGroup);
  scene.add(waypointGroup);
  showTogglePanel();
  repositionLegend();

  updateStats({
    jsonWpCount: orderedIds.length, jsonWpById: wpById,
    sampleCount: samples.length, pathMetrics: data.pathMetrics,
  });

}

// ── ArduPilot .waypoints Loading ──
function loadWaypoints(text, fileName) {
  if (ardupilotGroup) { scene.remove(ardupilotGroup); }
  if (ardupilotLineGroup) { scene.remove(ardupilotLineGroup); }

  ardupilotGroup = new THREE.Group();
  ardupilotGroup.name = 'ardupilot';
  ardupilotLineGroup = new THREE.Group();
  ardupilotLineGroup.name = 'ardupilot-line';

  const origin = getOrigin();
  const cosLat = Math.cos(origin.lat * Math.PI / 180);

  const lines = text.trim().split('\n');
  if (!lines[0].startsWith('QGC WPL')) {
    alert('Not a QGC WPL waypoints file');
    return;
  }

  // Parse metadata comments and waypoint rows
  let wplStartAlt = null;
  const wps = [];
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    // Parse ARUCO_NAV metadata comment
    const metaMatch = line.match(/^#\s*ARUCO_NAV\s+start_alt=([-\d.]+)/);
    if (metaMatch) {
      wplStartAlt = parseFloat(metaMatch[1]);
      document.getElementById('start-alt').value = wplStartAlt;
      continue;
    }
    if (line.startsWith('#') || line === '') continue;
    const cols = line.split('\t');
    if (cols.length < 12) continue;
    wps.push({
      idx: parseInt(cols[0]),
      frame: parseInt(cols[2]),
      cmd: parseInt(cols[3]),
      hold: parseFloat(cols[4]),
      yaw: parseFloat(cols[7]),
      lat: parseFloat(cols[8]),
      lon: parseFloat(cols[9]),
      alt: parseFloat(cols[10]),
    });
  }

  // Altitude reference: from WPL metadata, JSON, or manual StartAlt field
  const startAltField = parseFloat(document.getElementById('start-alt').value);
  const startAlt = wplStartAlt !== null ? wplStartAlt
    : jsonLoaded ? jsonStartAlt
    : (!isNaN(startAltField) ? startAltField : 0);

  const allPositions = []; // all waypoints including T/O and LND for connecting line
  let arduWpIdx = 0;

  for (const wp of wps) {
    if (wp.idx === 0) continue; // skip Home

    const north = (wp.lat - origin.lat) * 111111.0;
    const east = (wp.lon - origin.lon) * 111111.0 * cosLat;
    const ux = east, uz = north;
    const uy = wp.alt + startAlt;

    const sp = toScene({ x: ux, y: uy, z: uz });
    const isNav = (wp.cmd === CMD_WAYPOINT || wp.cmd === CMD_LOITER_TIME);

    // Determine marker style by command
    let color, size, label;
    if (wp.cmd === CMD_TAKEOFF) {
      color = 0xff8800; size = 0.18; label = 'T/O';
    } else if (wp.cmd === CMD_LAND) {
      color = 0xff0000; size = 0.18; label = 'LND';
    } else if (wp.cmd === CMD_LOITER_TIME) {
      color = 0xcc44ff; size = 0.14; label = `${wp.hold}s`;
    } else {
      color = 0xcc44ff; size = 0.12; label = null;
    }

    // Diamond marker (octahedron)
    const marker = new THREE.Mesh(
      new THREE.OctahedronGeometry(size, 0),
      new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9 })
    );
    marker.position.set(sp.x, sp.y, sp.z);
    arduWpIdx++;
    marker.userData = {
      wpId: wp.idx, source: 'ardupilot', cmd: wp.cmd, yaw: wp.yaw,
      hold: wp.hold, lat: wp.lat, lon: wp.lon, altRel: wp.alt,
      order: arduWpIdx,
      position: { x: ux, y: uy, z: uz },
    };
    ardupilotGroup.add(marker);

    allPositions.push(new THREE.Vector3(sp.x, sp.y, sp.z));

    // Yaw cone for nav waypoints
    if (isNav) {
      const cone = new THREE.Mesh(
        new THREE.ConeGeometry(0.05, 0.25, 6),
        new THREE.MeshBasicMaterial({ color: 0xcc44ff, transparent: true, opacity: 0.7 })
      );
      cone.rotation.x = Math.PI / 2;
      const pivot = new THREE.Group();
      pivot.position.set(sp.x, sp.y, sp.z);
      pivot.rotation.y = -THREE.MathUtils.degToRad(wp.yaw);
      cone.position.z = 0.25;
      pivot.add(cone);
      ardupilotGroup.add(pivot);
    }

    // Order label
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#2a0040';
    ctx.globalAlpha = 0.7;
    ctx.fillRect(0, 0, 64, 32);
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = '#cc44ff';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label || `A${arduWpIdx}`, 32, 16);
    const tex = new THREE.CanvasTexture(canvas);
    const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
    const sprite = new THREE.Sprite(spriteMat);
    sprite.position.set(sp.x, sp.y - 0.35, sp.z);
    sprite.scale.set(0.5, 0.25, 1);
    ardupilotGroup.add(sprite);
  }

  // Connecting line — full mission path including T/O and LND
  if (allPositions.length > 1) {
    const linePositions = [];
    for (const p of allPositions) { linePositions.push(p.x, p.y, p.z); }
    const lineGeo = new LineGeometry();
    lineGeo.setPositions(linePositions);
    const lineMat = new LineMaterial({
      color: 0xcc44ff, linewidth: 2, worldUnits: false,
      transparent: true, opacity: 0.7, dashed: true,
      dashSize: 4, gapSize: 2,
    });
    lineMat.resolution.set(viewport.clientWidth, viewport.clientHeight);
    const line = new Line2(lineGeo, lineMat);
    line.computeLineDistances();
    ardupilotLineGroup.add(line);
  }

  scene.add(ardupilotGroup);
  scene.add(ardupilotLineGroup);
  showTogglePanel();
  repositionLegend();

  updateStats({ arduWpCount: arduWpIdx, arduFile: fileName });
}

// ── Toggle panel ──
function showTogglePanel() {
  const panel = document.getElementById('toggle-panel');
  panel.style.display = 'block';

  // Show/hide rows based on what's loaded
  document.getElementById('chk-trajectory').closest('label').style.display =
    trajectoryGroup ? '' : 'none';
  document.getElementById('chk-waypoints').closest('label').style.display =
    waypointGroup ? '' : 'none';
  document.getElementById('chk-ardupilot').closest('label').style.display =
    ardupilotGroup ? '' : 'none';
  document.getElementById('chk-ardu-line').closest('label').style.display =
    ardupilotLineGroup ? '' : 'none';
}

// Wire up checkboxes
document.getElementById('chk-trajectory').addEventListener('change', (e) => {
  if (trajectoryGroup) trajectoryGroup.visible = e.target.checked;
});
document.getElementById('chk-waypoints').addEventListener('change', (e) => {
  if (waypointGroup) waypointGroup.visible = e.target.checked;
});
document.getElementById('chk-ardupilot').addEventListener('change', (e) => {
  if (ardupilotGroup) ardupilotGroup.visible = e.target.checked;
});
document.getElementById('chk-ardu-line').addEventListener('change', (e) => {
  if (ardupilotLineGroup) ardupilotLineGroup.visible = e.target.checked;
});
document.getElementById('chk-grid').addEventListener('change', (e) => {
  gridHelper.visible = e.target.checked;
  axesHelper.visible = e.target.checked;
});

function repositionLegend() {
  const infoPanel = document.getElementById('info-panel');
  const legendPanel = document.getElementById('legend-panel');
  legendPanel.style.display = 'block';
  if (infoPanel.style.display !== 'none') {
    legendPanel.style.top = (infoPanel.offsetTop + infoPanel.offsetHeight + 8) + 'px';
  } else {
    legendPanel.style.top = '12px';
  }
}

// ── Stats Panel ──
let statsData = {};

function updateStats(newData) {
  Object.assign(statsData, newData);
  const d = statsData;
  const parts = [];

  if (d.model) parts.push(`<b>Model:</b> ${d.model}`);
  if (d.box) {
    const s = new THREE.Vector3();
    d.box.getSize(s);
    parts.push(`<b>Bbox:</b> ${fmtN(s.x,1)}x${fmtN(s.y,1)}x${fmtN(s.z,1)}`);
  }
  if (d.jsonWpCount !== undefined) {
    let wpStr = `<b>JSON WPs:</b> ${d.jsonWpCount}`;
    if (d.jsonWpById) {
      const counts = {};
      for (const id of Object.keys(d.jsonWpById)) {
        const name = WP_NAMES[d.jsonWpById[id].type] || '?';
        counts[name] = (counts[name] || 0) + 1;
      }
      wpStr += ` <span class="label">(${Object.entries(counts).map(([k,v])=>`${v} ${k}`).join(', ')})</span>`;
    }
    parts.push(wpStr);
  }
  if (d.pathMetrics) parts.push(`<b>Path:</b> ${fmtN(d.pathMetrics.totalLength3D, 1)}m`);
  if (d.sampleCount) parts.push(`<b>Samples:</b> ${d.sampleCount}`);
  if (d.arduWpCount !== undefined) parts.push(`<b>ArduPilot WPs:</b> ${d.arduWpCount} <span class="label">(${d.arduFile})</span>`);

  const panel = document.getElementById('stats-panel');
  if (parts.length) {
    panel.innerHTML = parts.join(' &nbsp;|&nbsp; ');
    panel.style.display = 'block';
  }
}

// ── Click: read coordinates ──
renderer.domElement.addEventListener('click', (e) => {
  if (!modelGroup) return;
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const hits = raycaster.intersectObject(modelGroup, true);
  if (hits.length > 0) {
    const p = hits[0].point;
    clickMarker.position.copy(p);
    clickMarker.visible = true;

    // Scene coords → Unity coords (reverse X negate)
    const unity = { x: -p.x, y: p.y, z: p.z };
    const ned = unityToNED(unity);
    document.getElementById('info-unity').textContent =
      `X=${fmtN(unity.x)}, Y=${fmtN(unity.y)}, Z=${fmtN(unity.z)}`;
    document.getElementById('info-ned').textContent =
      `N=${fmtN(ned.n)}, E=${fmtN(ned.e)}, D=${fmtN(ned.d)}`;
    document.getElementById('info-alt').textContent = `${fmtN(ned.alt)} m`;

    document.getElementById('info-panel').style.display = 'block';
    repositionLegend();
  }
});

// ── Hover: waypoint tooltip (JSON + ArduPilot) ──
const tooltip = document.getElementById('tooltip');
renderer.domElement.addEventListener('mousemove', (e) => {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  // Collect hoverable meshes from both groups
  const targets = [];
  if (waypointGroup && waypointGroup.visible) {
    targets.push(...waypointGroup.children.filter(c => c.isMesh && c.userData.wpId !== undefined));
  }
  if (ardupilotGroup && ardupilotGroup.visible) {
    targets.push(...ardupilotGroup.children.filter(c => c.isMesh && c.userData.wpId !== undefined));
  }
  if (targets.length === 0) { tooltip.style.display = 'none'; return; }

  const hits = raycaster.intersectObjects(targets, false);
  if (hits.length > 0) {
    const d = hits[0].object.userData;
    let html;
    if (d.source === 'ardupilot') {
      const cmdName = { [CMD_WAYPOINT]: 'NAV_WAYPOINT', [CMD_TAKEOFF]: 'NAV_TAKEOFF',
        [CMD_LAND]: 'NAV_LAND', [CMD_LOITER_TIME]: 'NAV_LOITER_TIME' }[d.cmd] || `CMD_${d.cmd}`;
      html =
        `<b style="color:#cc44ff">ArduPilot #${d.order}</b> (idx:${d.wpId})<br>` +
        `Cmd: ${cmdName}<br>` +
        `Yaw: ${fmtN(d.yaw, 1)}° &nbsp; Hold: ${fmtN(d.hold, 1)}s<br>` +
        `Lat: ${d.lat.toFixed(7)} &nbsp; Lon: ${d.lon.toFixed(7)}<br>` +
        `Alt(rel): ${fmtN(d.altRel, 2)} m<br>` +
        `Unity: ${fmtN(d.position.x)}, ${fmtN(d.position.y)}, ${fmtN(d.position.z)}`;
    } else {
      const p = d.position;
      const ned = unityToNED(p);
      html =
        `<b>JSON WP #${d.order}</b> (id:${d.wpId})<br>` +
        `Type: ${d.typeName}<br>` +
        `Yaw: ${fmtN(d.yaw, 1)}°<br>` +
        `Unity: ${fmtN(p.x)}, ${fmtN(p.y)}, ${fmtN(p.z)}<br>` +
        `NED: N=${fmtN(ned.n)}, E=${fmtN(ned.e)}, D=${fmtN(ned.d)}`;
    }
    tooltip.innerHTML = html;
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX - rect.left + 14) + 'px';
    tooltip.style.top = (e.clientY - rect.top + 14) + 'px';
  } else {
    tooltip.style.display = 'none';
  }
});

// ── Keyboard shortcuts ──
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT') return;
  const k = e.key.toLowerCase();
  if (k === 'r' && modelGroup) {
    fitCameraToBox(new THREE.Box3().setFromObject(modelGroup));
  } else if (k === 'g') {
    const v = !gridHelper.visible;
    gridHelper.visible = v; axesHelper.visible = v;
    document.getElementById('chk-grid').checked = v;
  } else if (k === 't' && trajectoryGroup) {
    trajectoryGroup.visible = !trajectoryGroup.visible;
    document.getElementById('chk-trajectory').checked = trajectoryGroup.visible;
  } else if (k === 'w' && waypointGroup) {
    waypointGroup.visible = !waypointGroup.visible;
    document.getElementById('chk-waypoints').checked = waypointGroup.visible;
  } else if (k === 'a') {
    if (ardupilotGroup) {
      ardupilotGroup.visible = !ardupilotGroup.visible;
      document.getElementById('chk-ardupilot').checked = ardupilotGroup.visible;
    }
    if (ardupilotLineGroup) {
      ardupilotLineGroup.visible = !ardupilotLineGroup.visible;
      document.getElementById('chk-ardu-line').checked = ardupilotLineGroup.visible;
    }
  } else if (k === 'c') {
    toggleConvertPanel();
  }
});

// ── Convert Panel ──
function toggleConvertPanel() {
  const panel = document.getElementById('convert-panel');
  panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
}

document.getElementById('conv-close').addEventListener('click', () => {
  document.getElementById('convert-panel').style.display = 'none';
});

function fmtWpRow(index, current, frame, cmd, p1, p2, p3, p4, lat, lon, alt) {
  return `${index}\t${current}\t${frame}\t${cmd}\t${p1.toFixed(6)}\t${p2.toFixed(6)}\t${p3.toFixed(6)}\t${p4.toFixed(6)}\t${lat.toFixed(7)}\t${lon.toFixed(7)}\t${alt.toFixed(3)}\t1`;
}

function nedToLatLon(north, east, originLat, originLon) {
  const lat = originLat + north / 111111.0;
  const lon = originLon + east / (111111.0 * Math.cos(originLat * Math.PI / 180));
  return { lat, lon };
}

function convertJsonToWaypoints(data) {
  const origin = getOrigin();
  const altOffset = parseFloat(document.getElementById('conv-alt-offset').value) || 0;
  const record360Time = parseFloat(document.getElementById('conv-360-time').value) || 30;
  const noTakeoff = document.getElementById('conv-no-takeoff').checked;
  const noLand = document.getElementById('conv-no-land').checked;
  const originAlt = 100.0;

  // Build wp lookup
  const wpById = {};
  for (const wp of data.detailedWaypoints) {
    if (wp.wasDeleted) continue;
    wpById[wp.id] = wp;
  }

  // Traversal order from segments
  const segments = data.detailedSegments || [];
  let orderedIds = null;
  if (segments.length > 0) {
    const nextWp = {};
    for (const seg of segments) nextWp[seg.fromId] = seg.toId;
    orderedIds = [];
    let current = nextWp[-1];
    const visited = new Set();
    while (current !== undefined && current !== -2 && !visited.has(current)) {
      if (wpById[current]) orderedIds.push(current);
      visited.add(current);
      current = nextWp[current];
    }
  }
  if (!orderedIds || orderedIds.length === 0) {
    orderedIds = Object.keys(wpById).map(Number);
  }

  // Start altitude
  let segStartAlt;
  if (segments.length > 0) {
    segStartAlt = segments[0].fromPos.y;
  } else if (orderedIds.length > 0) {
    segStartAlt = wpById[orderedIds[0]].position.y;
  } else {
    segStartAlt = 0;
  }

  // Start position for takeoff/home
  const startPos = segments.length > 0 ? segments[0].fromPos : null;

  // Build waypoints
  const waypoints = [];
  for (const wid of orderedIds) {
    const wp = wpById[wid];
    const pos = wp.position;
    const north = pos.z, east = pos.x;
    const alt = pos.y - segStartAlt + altOffset;
    const { lat, lon } = nedToLatLon(north, east, origin.lat, origin.lon);
    const yaw = wp.yaw || 0;
    const wtype = wp.type || 0;
    const cmd = wtype === 2 ? 19 : 16; // Record360→LOITER_TIME, else→NAV_WP
    let hold;
    if (wtype === 1) hold = 2.0;
    else if (wtype === 2) hold = record360Time;
    else hold = 0.0;
    waypoints.push({ lat, lon, alt, cmd, hold, yaw });
  }

  // Build mission lines
  const lines = ['QGC WPL 110'];
  lines.push(`# ARUCO_NAV start_alt=${segStartAlt.toFixed(4)}`);

  // Takeoff position
  let toLat, toLon;
  if (startPos) {
    ({ lat: toLat, lon: toLon } = nedToLatLon(startPos.z, startPos.x, origin.lat, origin.lon));
  } else if (waypoints.length) {
    toLat = waypoints[0].lat; toLon = waypoints[0].lon;
  } else {
    toLat = origin.lat; toLon = origin.lon;
  }

  // Home (index 0)
  lines.push(fmtWpRow(0, 1, 0, 16, 0, 0, 0, 0, toLat, toLon, originAlt));
  let idx = 1;

  // Takeoff
  if (!noTakeoff) {
    const takeoffAlt = waypoints.length > 0 ? waypoints[0].alt : 1.5;
    lines.push(fmtWpRow(idx, 0, 3, 22, 0, 0, 0, 0, toLat, toLon, takeoffAlt));
    idx++;
  }

  // Waypoints
  for (const wp of waypoints) {
    lines.push(fmtWpRow(idx, 0, 3, wp.cmd, wp.hold, 0, 0, wp.yaw, wp.lat, wp.lon, wp.alt));
    idx++;
  }

  // Land
  if (!noLand) {
    const landLat = waypoints.length > 0 ? waypoints[waypoints.length - 1].lat : origin.lat;
    const landLon = waypoints.length > 0 ? waypoints[waypoints.length - 1].lon : origin.lon;
    lines.push(fmtWpRow(idx, 0, 3, 21, 0, 0, 0, 0, landLat, landLon, 0));
  }

  return { text: lines.join('\n') + '\n', wpCount: waypoints.length };
}

function downloadFile(text, filename) {
  const blob = new Blob([text], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

document.getElementById('conv-btn').addEventListener('click', () => {
  if (!jsonData) return;
  try {
    const result = convertJsonToWaypoints(jsonData);
    const outName = jsonFileName.replace(/\.json$/i, '.waypoints') || 'mission.waypoints';
    downloadFile(result.text, outName);
    document.getElementById('conv-status').textContent = `✓ ${result.wpCount} WPs → ${outName}`;
    document.getElementById('conv-status').style.color = '#00ff88';
  } catch (err) {
    document.getElementById('conv-status').textContent = `✗ ${err.message}`;
    document.getElementById('conv-status').style.color = '#ff4444';
  }
});

// ── File Inputs ──
document.getElementById('glb-input').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => loadGLB(reader.result, file.name);
  reader.readAsArrayBuffer(file);
});

document.getElementById('json-input').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const data = JSON.parse(reader.result);
      if (!data.detailedWaypoints) { alert('JSON: no detailedWaypoints'); return; }
      jsonFileName = file.name;
      loadTrajectory(data, file.name);
    } catch (err) { alert('Invalid JSON: ' + err.message); }
  };
  reader.readAsText(file);
});

document.getElementById('wpl-input').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => loadWaypoints(reader.result, file.name);
  reader.readAsText(file);
});

// ── Drag and Drop ──
const dropOverlay = document.getElementById('drop-overlay');
let dragCounter = 0;

viewport.addEventListener('dragenter', (e) => {
  e.preventDefault(); dragCounter++;
  dropOverlay.style.display = 'flex';
});
viewport.addEventListener('dragleave', (e) => {
  e.preventDefault(); dragCounter--;
  if (dragCounter <= 0) { dropOverlay.style.display = 'none'; dragCounter = 0; }
});
viewport.addEventListener('dragover', (e) => { e.preventDefault(); });
viewport.addEventListener('drop', (e) => {
  e.preventDefault();
  dropOverlay.style.display = 'none';
  dragCounter = 0;

  for (const file of e.dataTransfer.files) {
    const ext = file.name.split('.').pop().toLowerCase();
    if (ext === 'glb' || ext === 'gltf') {
      const reader = new FileReader();
      reader.onload = () => loadGLB(reader.result, file.name);
      reader.readAsArrayBuffer(file);
    } else if (ext === 'json') {
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          if (data.detailedWaypoints) {
            jsonFileName = file.name;
            loadTrajectory(data, file.name);
          }
        } catch (_) {}
      };
      reader.readAsText(file);
    } else if (ext === 'waypoints' || ext === 'txt') {
      const reader = new FileReader();
      reader.onload = () => loadWaypoints(reader.result, file.name);
      reader.readAsText(file);
    }
  }
});

// ── Handle window resize for fat lines ──
window.addEventListener('resize', () => {
  for (const grp of [trajectoryGroup, ardupilotLineGroup]) {
    if (grp) grp.traverse((child) => {
      if (child.material && child.material.resolution) {
        child.material.resolution.set(viewport.clientWidth, viewport.clientHeight);
      }
    });
  }
});
</script>

<div id="tutorial-backdrop"></div>
<div id="tutorial-card">
  <div class="tut-title"></div>
  <div class="tut-body"></div>
  <div class="tut-footer">
    <span class="tut-step"></span>
    <div class="tut-btns">
      <button class="tut-skip">Skip</button>
      <button class="tut-back">Back</button>
      <button class="tut-next tut-primary">Next</button>
    </div>
  </div>
</div>

<script>
(function() {
  const STEPS = [
    { target: null, title: 'Welcome',
      body: 'Drone Mission Viewer lets you visualize 3D building models with drone flight paths and ArduPilot missions. Let\u2019s walk through the main features.' },
    { target: '#file-btns-group', title: 'Load Files',
      body: 'Use these buttons to load files: <b>GLB</b> for 3D models, <b>JSON</b> for VR planner missions, <b>WPL</b> for ArduPilot waypoints. You can also drag & drop files onto the viewport.' },
    { target: '#coords-group', title: 'Coordinates',
      body: 'Set the GPS origin for coordinate conversion. <b>StartAlt</b> is the Unity Y of the arming position \u2014 it\u2019s auto-filled when you load a JSON file.' },
    { target: null, title: '3D Navigation',
      body: '<b>Left-drag</b> to orbit, <b>right-drag</b> to pan, <b>scroll</b> to zoom. Click on the 3D model to see Unity/NED coordinates. Hover over waypoints for details.' },
    { target: '#toggle-panel', title: 'Layers',
      body: 'Toggle visibility of flight paths, waypoints, ArduPilot missions, and the grid. This panel appears after loading data.' },
    { target: '#convert-panel', title: 'Convert Panel',
      body: 'Press <b>C</b> to open. Converts VR planner <b>JSON → .waypoints</b> for ArduPilot. Set alt offset and 360° loiter time, then click the button to download.' },
    { target: null, title: 'Keyboard Shortcuts',
      body: 'Quick keys: <b>R</b> reset camera, <b>G</b> grid, <b>T</b> trajectory, <b>W</b> waypoints, <b>A</b> ArduPilot, <b>C</b> convert panel. Press <b>?</b> anytime to replay this tour.' },
  ];

  let currentStep = 0;
  let prevHighlight = null;
  const backdrop = document.getElementById('tutorial-backdrop');
  const card = document.getElementById('tutorial-card');
  const navbar = document.getElementById('navbar');

  function startTutorial() {
    currentStep = 0;
    backdrop.style.display = 'block';
    card.style.display = 'block';
    showStep(0);
  }

  function endTutorial() {
    backdrop.style.display = 'none';
    card.style.display = 'none';
    clearHighlight();
    localStorage.setItem('tutorial_done', '1');
  }

  let tutTempShown = null;

  function clearHighlight() {
    if (prevHighlight) {
      prevHighlight.classList.remove('tutorial-highlight');
      prevHighlight = null;
    }
    if (tutTempShown) {
      tutTempShown.style.display = 'none';
      tutTempShown = null;
    }
    navbar.style.zIndex = '100';
  }

  function showStep(n) {
    currentStep = n;
    const step = STEPS[n];
    clearHighlight();

    let targetEl = step.target ? document.querySelector(step.target) : null;
    // Temporarily show hidden panels for tutorial highlight
    if (targetEl && getComputedStyle(targetEl).display === 'none') {
      targetEl.style.display = 'block';
      tutTempShown = targetEl;
    }
    if (targetEl && !targetEl.offsetParent && !navbar.contains(targetEl)) {
      targetEl = null;
    }

    if (targetEl) {
      targetEl.classList.add('tutorial-highlight');
      prevHighlight = targetEl;
      if (navbar.contains(targetEl)) navbar.style.zIndex = '1001';
    }

    card.querySelector('.tut-title').textContent = step.title;
    card.querySelector('.tut-body').innerHTML = step.body;
    card.querySelector('.tut-step').textContent = (n + 1) + ' of ' + STEPS.length;
    card.querySelector('.tut-back').style.display = n === 0 ? 'none' : '';
    card.querySelector('.tut-next').textContent = n === STEPS.length - 1 ? 'Done' : 'Next';

    positionCard(targetEl);
  }

  function positionCard(targetEl) {
    var cardW = card.offsetWidth, cardH = card.offsetHeight;
    var viewW = window.innerWidth, viewH = window.innerHeight;

    if (!targetEl) {
      card.style.top = (viewH / 2 - cardH / 2) + 'px';
      card.style.left = (viewW / 2 - cardW / 2) + 'px';
      return;
    }

    var rect = targetEl.getBoundingClientRect();
    var gap = 12;
    var top = rect.bottom + gap;
    var left = rect.left + rect.width / 2 - cardW / 2;

    if (top + cardH > viewH - gap) top = rect.top - cardH - gap;
    left = Math.max(gap, Math.min(left, viewW - cardW - gap));
    top = Math.max(gap, Math.min(top, viewH - cardH - gap));

    card.style.top = top + 'px';
    card.style.left = left + 'px';
  }

  card.querySelector('.tut-next').addEventListener('click', function() {
    if (currentStep >= STEPS.length - 1) endTutorial();
    else showStep(currentStep + 1);
  });
  card.querySelector('.tut-back').addEventListener('click', function() {
    if (currentStep > 0) showStep(currentStep - 1);
  });
  card.querySelector('.tut-skip').addEventListener('click', endTutorial);

  document.getElementById('help-btn').addEventListener('click', startTutorial);

  document.addEventListener('keydown', function(e) {
    if (e.target.tagName === 'INPUT') return;
    if (e.key === '?') { e.preventDefault(); startTutorial(); }
    if (e.key === 'Escape' && backdrop.style.display === 'block') endTutorial();
  });

  if (!localStorage.getItem('tutorial_done')) startTutorial();
})();
</script>
</body>
</html>
